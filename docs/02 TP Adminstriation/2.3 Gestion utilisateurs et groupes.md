# 2.3 Gestion des utilisateurs et groupes

> [!cite]  â˜• Ã€ la machine Ã  cafÃ© de CorpTech ðŸ§
> - *Â« Ã‡a commence Ã  me gonflerâ€¦ je nâ€™ai plus accÃ¨s au dossier commun . Â»* 
> - *Â« Ben utilise le compte `invite2`. Tout le monde fait Ã§a... Â»*

Lorsque un compte partagÃ© devient la solution par dÃ©faut aux problÃ¨mes dâ€™accÃ¨s,  il ne sâ€™agit pas seulement dâ€™une mauvaise pratique, mais dâ€™une **faille de sÃ©curitÃ© structurelle**.

Les comptes partagÃ©s empÃªchent toute traÃ§abilitÃ©, rendent impossible une gestion des accÃ¨s  et permettent de contourner les mÃ©canismes de sÃ©curitÃ© du systÃ¨me.

La mise en place de comptes nominatifs et de groupes adaptÃ©s sont indispensable pour reprÃ©senter correctement :
 1) lâ€™organisation de lâ€™entreprise
 2) assurer une administration **fiable et sÃ©curisÃ©e** du systÃ¨me.
## 2.3.1 Introduction
Dans un systÃ¨me Unix/Linux, un **compte utilisateur** nâ€™est pas seulement un nom :  
il correspond Ã  un **identifiant numÃ©rique unique**, appelÃ© **UID** (_User ID_).  
De mÃªme, chaque groupe possÃ¨de un **identifiant numÃ©rique**, le **GID** (_Group ID_).  
Ces identifiants permettent au noyau de diffÃ©rencier les comptes et de structurer leurs accÃ¨s.

> [!note] Selon _The Linux Programming Interface_ :
Â« Every process has a set of associated numeric user identifiers (UIDs) and group identifiers (GIDs). Â»

Cela signifie quâ€™au moment oÃ¹ un utilisateur lance un programme,  le processus **hÃ©rite de lâ€™UID et du GID** du compte qui lâ€™exÃ©cute.  

**Pourquoi est-ce indispensable Ã  comprendre pour gÃ©rer les utilisateurs ?**  
Parce que ces identifiants (UID/GID) sont les informations que le noyau utilisera plus tard  pour vÃ©rifier si un processus est autorisÃ© ou non Ã  accÃ©der Ã  un fichier ou Ã  une ressource.  

Ce mÃ©canisme est Ã  la base du fonctionnement du modÃ¨le de permissions POSIX utilisÃ© par toutes les distributions Linux.

> [!NOTE]  En rÃ©sumÃ© :
> - Chaque utilisateur possÃ¨de un UID (User ID).;
> - Chaque groupe possÃ¨de un  GID  (Group ID).;
> - Un processus hÃ©rite de ces identifiants ;
> - Ces identifiants seront utilisÃ©s par le noyau pour Ã©valuer les permissions (point dÃ©veloppÃ© plus loin dans le TP).
> - **UID, GID et appartenance aux groupes**  constituent la base de la gestion des utilisateurs sous Unix/Linux.

##  2.3.2 Les fichiers systÃ¨mes liÃ©s aux utilisateurs
Pour fonctionner, la gestion des comptes sâ€™appuie sur plusieurs fichiers de configuration. Ils ne doivent jamais Ãªtre modifiÃ©s Ã  la main dans un environnement de production, mais il est indispensable dâ€™en connaÃ®tre le rÃ´le.

**Fichier `/etc/passwd`**
Ce fichier rÃ©pertorie **lâ€™ensemble des comptes du systÃ¨me** (comptes utilisateur et comptes systÃ¨me).  
Pour chaque compte, il indique :
- le **nom du compte** ; 
- son **UID** (_User ID_) ;
- son **GID principal** (_Group ID_) ;
- son **dossier personnel** ;
- son **shell de connexion**.

> [!NOTE]  
> Le mot du fichier â€œpasswdâ€ est historique : **les mots de passe nâ€™y sont plus stockÃ©s** depuis longtemps.

Afficher le fichier `/etc/passwd` 
```
cat /etc/passwd
```

Vous devriez obtenir quelque chose comme ceci:
```
/home/etudiant # cat /etc/passwd
root:x:0:0:root:/root:/bin/sh
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/mail:/sbin/nologin
news:x:9:13:news:/usr/lib/news:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin
cron:x:16:16:cron:/var/spool/cron:/sbin/nologin
ftp:x:21:21::/var/lib/ftp:/sbin/nologin
sshd:x:22:22:sshd:/dev/null:/sbin/nologin
games:x:35:35:games:/usr/games:/sbin/nologin
ntp:x:123:123:NTP:/var/empty:/sbin/nologin
guest:x:405:100:guest:/dev/null:/sbin/nologin
nobody:x:65534:65534:nobody:/:/sbin/nologin
klogd:x:100:101:klogd:/dev/null:/sbin/nologin
etudiant:x:1000:1000::/home/etudiant:/bin/sh
```
On retrouve bien notre utilisateur `Ã©tudiant`.  
```
etudiant:x:1000:1000::/home/etudiant:/bin/sh
```
Pour Alpine Linux (comme toutes les distros Unix), la signification des champs est la mÃªme :

|                  | Champ        | Signification                                   |
| ---------------- | ------------ | ----------------------------------------------- |
| `etudiant`       | login        | nom du compte                                   |
| `x`              | mot de passe | stockÃ© dans `/etc/shadow`                       |
| `1000`           | UID          | identifiant utilisateur du compte               |
| `1000`           | GID          | identifiant de groupe principal                 |
| vide             | info         | champ â€œgecosâ€ (description facultative)         |
| `/home/etudiant` | home         | emplacement du dossier personnel                |
| `/bin/sh`        | shell        | programme lancÃ© automatiquement  Ã  la connexion |
**Fichier`/etc/shadow`**
Ce fichier contient les **empreintes de mots de passe** (hachÃ©es).  
Il est **strictement rÃ©servÃ© au systÃ¨me** et nâ€™est lisible que par `root`.

> [!NOTE]  
> **les mots de passe ne sont pas stockÃ©s dans `/etc/passwd`.**

**Fichier `/etc/group`**
Ce fichier rÃ©pertorie **tous les groupes du systÃ¨me**. Pour chaque groupe, il indique :
- le **nom** du group;
- son **GID** (_Group ID_) ;
- la liste des **membres** faisant partie de ce groupe.
```
cat /etc/group
```

Remarquez la ligne concernant le groupe `wheel`
```
 wheel:x:10:root,etudiant
```
Rappelez-vous nous avons ajoutÃ© l'utilisateur `etudiant` au groupe `wheel` pour qu'il soit autorisÃ© Ã  utilisÃ© la commande `sudo`. C'est pour cela que nous voyons l'utilisateur `etudiant` figurÃ© dans la liste des menbres de `wheel`.

# 2.3.2 Travaux dirigÃ©s
## 2.3.2.1 CrÃ©ation des utilisateurs
Pour crÃ©er un utilisateur la commande est `adduser` (busybox). CommenÃ§ons par afficher  les options disponible de cette commande, tapez `adduser --help`
```
/home/etudiant #  adduser --help
BusyBox v1.37.0 (2025-08-05 16:40:33 UTC) multi-call binary.

Usage: adduser [OPTIONS] USER [GROUP]

Create new user, or add USER to GROUP

	-h DIR		Home directory
	-g GECOS	GECOS field
	-s SHELL	Login shell
	-G GRP		Group
	-S		Create a system user
	-D		Don't assign a password
	-H		Don't create home directory
	-u UID		User id
	-k SKEL		Skeleton directory (/etc/skel)

```

Pour ce travail on va mettre simuler la mise en place dâ€™une petite Ã©quipe de travail avec 5 comptes.

|Compte|RÃ´le|Exigence|
|---|---|---|
|**alice**|dÃ©veloppeuse|home standard|
|**bob**|administrateur junior|doit Ãªtre ajoutÃ© Ã  _wheel_ + home personnalisÃ©|
|**invite**|invitÃ© temporaire|pas de shell, pas de mot de passe|
|**serviceapp**|service interne|compte systÃ¨me, pas de home|
|**stagiaire**|compte mal configurÃ© volontairement|Ã  diagnostiquer et rÃ©parer|
## **PARTIE 1 â€” CrÃ©ation et observation

## 1) CrÃ©er le compte **alice**

```
adduser alice
```

### VÃ©rifications

- UID, GID, home, shell :
    ```
    grep alice /etc/passwd
    id alice
    ```

> [!NOTE]
> Quels est l' UID, le groupe principale et la  home du compte alice ?

## 2) CrÃ©er le compte **bob**

### Ã‰tape 1 â€” CrÃ©er bob avec un home sur un stockage sÃ©parÃ©
```
adduser -h /data/bob bob
```
### Ã‰tape 2 â€” Donner les droits administrateur (wheel)
```
adduser bob wheel
```
### Ã‰tape 3 â€” Forcer un shell diffÃ©rent
```
adduser -s /bin/ash bob
```
### VÃ©rifications
- bob est dans wheel ?
    ```
    id bob
    ```
- bob a un shell diffÃ©rent ?
    ```
    grep bob /etc/passwd
    ```
- bob possÃ¨de bien `/data/bob` ?
    ```
    ls -ld /data/bob
    ```

## 3) CrÃ©er **invite**, un compte temporaire **bloquÃ© par dÃ©faut**

```
adduser -D -h /tmp/invite -s /sbin/nologin invite
```
### VÃ©rifications
- se connecter â†’ Ã©chec normal
    ```
    su - invite
    ```
`This account is not available`: raison de lâ€™Ã©chec â†’ `nologin`
## 4) CrÃ©er **serviceapp**, un vrai compte de service
```
adduser -S -H serviceapp
```
### VÃ©rifications
```
id serviceapp
grep serviceapp /etc/passwd
```

> [!NOTE] A noter
> - UID < 1000 â†’ compte systÃ¨me
> - pas de home (option âˆ’H)
> - shell `nologin` (par dÃ©faut pas de connexion pour un compte systÃ¨me)

## 5) CrÃ©er **stagiaire**, mais avec des erreurs volontaires
Maintenant on va crÃ©e un compte **mal paramÃ©trÃ©**. A vous de diagnostiquer le problÃ¨me et de le rÃ©parer: Pour commencer, copier/coller cette commande
```
adduser -H -D -s /sbin/nologin stagiaire
```
### Travail demandÃ© : corriger le compte
1. Doit possÃ©der son rÃ©pertoire personnel dans /home/stagiaire :
2. Son shell doit Ãªtre `sh`    
3. PossÃ©der un mode passe 

## Le rÃ©pertoire skeleton (`/etc/skel`)
Lorsquâ€™un utilisateur est crÃ©Ã© sous Alpine Linux, son rÃ©pertoire personnel est presque entiÃ¨rement vide. Il ne contient que les Ã©lÃ©ments gÃ©nÃ©rÃ©s automatiquement par les outils systÃ¨me (comme `.ash_history` lorsque le shell BusyBox `ash` dÃ©marre pour la premiÃ¨re fois).

Alpine ne fournit aucun fichier de configuration par dÃ©faut : pas de `.profile`, pas de structure de travail, aucune personnalisation.  
Câ€™est Ã  lâ€™administrateur de dÃ©cider ce qui doit exister dans chaque nouvel espace utilisateur.  
Pour cela, il peut utiliser le rÃ©pertoire `/etc/skel`, dont le contenu sera copiÃ© dans chaque nouveau HOME â€” uniquement si lâ€™administrateur le renseigne.

Lâ€™administrateur peut remplir `/etc/skel` pour prÃ©parer :
- une structure de dossiers,
- des fichiers de configuration,
- un message dâ€™accueil,
- ou tout autre Ã©lÃ©ment commun.

Tout ce qui se trouve dans `/etc/skel` sera **copiÃ© tel quel** pour chaque crÃ©ation dâ€™un utilisateur avec `adduser`.

On va prÃ©parer des dossiers standard pour rendre lâ€™environnement plus intuitif pour des utilisateurs habituÃ©s Ã  Windows :
```
mkdir -p /etc/skel/Documents
mkdir -p /etc/skel/Images
mkdir -p /etc/skel/TÃ©lÃ©chargements
mkdir -p /etc/skel/VidÃ©os
mkdir -p /etc/skel/Musique`
```

On vÃ©rifie :
`ls /etc/skel`

Lors de la crÃ©ation dâ€™un nouvel utilisateur, ces dossiers apparaÃ®tront automatiquement dans son HOME.

On peut Ã©galement ajouter un fichier `.profile`:
Le fichier **`.profile`** est un script exÃ©cutÃ© automatiquement **Ã  chaque ouverture de session utilisateur** .
Ce fichier permet :
- dâ€™exÃ©cuter des commandes Ã  chaque connexion,
- de configurer le shell,
- de dÃ©finir des paramÃ¨tres,

PlacÃ©e dans `/etc/skel`, la version modÃ¨le de `.profile` est copiÃ©e dans le HOME de chaque nouvel utilisateur. Cela permet de standardiser automatiquement lâ€™environnement et la configuration de tous les comptes crÃ©Ã©s.

Voici un fichier `/etc/skel/.profile` (Copier/coller). Il ne fait pas grand chois Ã  part dire "Bienvenue" Ã  chaque nouvel utilisateur. 
```
cat > /etc/skel/.profile << 'EOF'
echo "----------------------------------------"
echo "Bienvenue sur votre espace personnel !"
echo "Vos dossiers Documents, Images, etc. sont prÃªts."
echo "Bonne prise en main de votre environnement Alpine."
echo "----------------------------------------"
EOF
```

Maintenant crÃ©ons un nouvelle utilisateur:
```
adduser -k /etc/skel-projet clara
```

Un petit test
```
su - clara
```

## Changer dâ€™utilisateur avec `su`

Il arrive quâ€™un administrateur doive agir Â« Ã  la place Â» dâ€™un autre utilisateur sans fermer sa propre session : tester ses droits, accÃ©der Ã  son environnement, ou exÃ©cuter une commande sous son identitÃ©.  
La commande **`su`** sert prÃ©cisÃ©ment Ã  cela.

Quand on tape **`su clara`**, on demande au systÃ¨me de **changer lâ€™identitÃ© utilisÃ©e par le shell courant**.  Techniquement, le processus reste le mÃªme, mais son **UID/GID effectifs** deviennent ceux de clara.  On agit donc comme clara, mais _dans le shell de dÃ©part_.  Son environnement nâ€™est pas rechargÃ© : on garde le mÃªme rÃ©pertoire courant, les mÃªmes variables, et aucun fichier de configuration de clara nâ€™est exÃ©cutÃ©.

Pour vÃ©rifier ce comportement, on peut observer :

```
pwd          # rÃ©pertoire de travail actuel
su clara     # Changement d'identitÃ©
id           # Afficje l'UID de clara
pwd          # inchangÃ©
```

Et donc pas de message de bienvenue. 

Ã€ lâ€™inverse, **`su - clara`** demande lâ€™ouverture dâ€™une **nouvelle session**, comme si `clara` venait de se connecter normalement.  

On obtient bien cette fois-ci notre message de bienvenue. Un nouveau shell a Ã©tÃ© lancÃ© : le rÃ©pertoire courant devient `/home/alice`, ses fichiers de configuration sont exÃ©cutÃ©s et son environnement est reconstruit.

```
su - clara
id           # identitÃ© de clara
pwd          # /home/clara
```

**En bref :**  
`su clara â†’ on change dâ€™identitÃ© dans le mÃªme shell.  
`su - clara â†’ on ouvre une vraie session pour clara.

---
**Auteur :** J-F Ornech 
**Formation :** BTS SIO â€“ SISR  
**Ã‰tablissement :** LycÃ©e Merleau-Ponty
AnnÃ©e : 2025â€“2026

---
