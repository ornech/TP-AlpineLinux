Temps pr√©vu : 2h
## 2.3c Ouverture de session & profil

> [!cite] ‚òï √Ä la machine √† caf√© de CorpTech  
> 2 coll√®gues √† la machine √† caf√©:
>  - *¬´ Au fait, le compte `invite2` existe toujours ? ¬ª*  
>  - *¬´ Je ne crois pas. J‚Äôai cru comprendre qu‚Äôon devait maintenant utiliser nos comptes individuels‚Ä¶ et il y a aussi une histoire de groupes. Je n‚Äôai pas tout compris, en tout cas pour moi √ßa marche plus ... ¬ª*  
>  - *¬´ Ah‚Ä¶ du coup, avant √ßa marchait, mais on ne savait pas pourquoi.*  
>  - *Et maintenant √ßa marche plus, mais au moins on sait pourquoi... ¬ª * üò§

> [!NOTE]  Cette situation met en √©vidence un point essentiel :  
> Comprendre pourquoi un acc√®s fonctionne ou non suppose de savoir **√† quel moment** et **comment** le syst√®me reconna√Æt un utilisateur et lui attribue un contexte de travail.

Sur un syst√®me Unix/Linux, il est essentiel de distinguer **l‚Äôauthentification** de **l‚Äôouverture de session**, m√™me si ces deux √©tapes sont souvent assur√©es par le m√™me programme (`login` en local, `sshd` √† distance).

**L‚Äôauthentification** r√©pond √† la question _¬´ Qui es tu ? ¬ª_.  
Elle consiste uniquement √† v√©rifier une identit√© √† l‚Äôaide d‚Äôun mot de passe ou d‚Äôune cl√© SSH. Conceptuellement, cette √©tape s‚Äôappuie sur **`/etc/shadow`**, qui contient les informations n√©cessaires √† la validation de l‚Äôidentit√©. Tant que l‚Äôauthentification n‚Äôa pas abouti, aucun contexte utilisateur n‚Äôest cr√©√© : aucun UID n‚Äôest appliqu√© et aucun programme utilisateur n‚Äôest lanc√©.

Une fois l‚Äôidentit√© valid√©e, vient **l‚Äôouverture de session**. Cette √©tape d√©finit le **contexte d‚Äôex√©cution** sur le syst√®me. Elle s‚Äôappuie sur **`/etc/passwd`** et **`/etc/group`**, qui fournissent l‚ÄôUID, les groupes, le r√©pertoire personnel et le programme associ√© au compte. C‚Äôest √† ce moment-l√† que la session utilisateur est r√©ellement cr√©√©e.

Le programme associ√© au compte est alors lanc√© dans cette session. Il s‚Äôagit le plus souvent d‚Äôun shell interactif, mais ce choix d√©pend de l‚Äôusage pr√©vu pour le compte.

En r√©sum√© :  
**`/etc/shadow` sert √† authentifier**,  
**`/etc/passwd` et `/etc/group` servent √† ouvrir une session**,  
et **le programme associ√© au compte est ex√©cut√© dans cette session**.

> [!NOTE] **Le shell n‚Äôest pas obligatoire**  
> Tous les comptes Unix/Linux n‚Äôont pas vocation √† disposer d‚Äôun shell interactif. Certains sont destin√©s uniquement √† l‚Äôex√©cution de services ou de commandes automatiques ; leur associer un programme non interactif permet de **restreindre l‚Äôacc√®s au syst√®me**. Le shell est donc un **outil r√©serv√© aux sessions interactives**, pas une obligation g√©n√©rale.

``` mermaid
flowchart TB
    I["Interface<br/>(terminal, console, SSH,<br/>tty)"]
    A["Authentification syst√®me<br/>(login ou sshd)"]
    SESS["Session utilisateur<br/>(UID, groupes, environnement)"]
    P["Programme associ√© au compte<br/>(shell ou programme non interactif)"]
    K["Noyau<br/>(CPU, m√©moire,<br/>fichiers, p√©riph√©riques)"]

    I -->|identifiants| A
    A -->|authentification r√©ussie| SESS
    SESS -->|lance| P
    P -->|demande l‚Äôacc√®s<br/>aux ressources| K

```
### Travaux dirig√©s : Connexion SSH vs connexion locale
Nous allons observer la diff√©rence entre une **connexion distante (SSH)** et une **connexion locale (console / tty)**. Le but est de comprendre **quel programme authentifie**, **quand une session est cr√©√©e**, et **ce que devient le shell**.

> [!warning] Pr√©-requis
> Vous devez absolutment avoir aucun compte de connect√© sur votre VM. Si vous avez fait des manipulations et qu'une session est ouverte en local ou √† distance fermez absolument tout en tapant exit, autant de fois qu'il le faudra pour n'avoir plus que l'invite de loggin qui s'affiche.

#### √âtape 1:  Connexion SSH
Depuis une machine distante connectez-vous √† l'aide de ssh:
```sh
ssh alice@IP_DE_LA_VM
```
puis
```sh
alpine:~$ ps | grep alice
```

R√©sultats attendu:
```sh
 2514 root      0:00 sshd-session: alice [priv]
 2516 alice     0:00 sshd-session: alice@pts/0
 2517 alice     0:00 -sh
 2666 alice     0:00 ps
 2667 alice     0:00 grep alice
alpine:~$ 
```
puis fermez la session ssh avec la commande `exit`.

> [!NOTE] Explications
> La sortie de `ps` montre que la connexion SSH est d‚Äôabord prise en charge par un processus ex√©cut√© avec l‚Äôidentit√© **root**, visible sous la forme `sshd-session: alice [priv]`. Ce processus assure l‚Äôauthentification et pr√©pare l‚Äôouverture de la session. 
> Une fois l‚Äôidentit√© valid√©e, la **session utilisateur** est ouverte et appara√Æt sous la forme `sshd-session: alice@pts/0`, cette fois ex√©cut√©e avec l‚Äôidentit√© de **alice**. 
> Le shell (`-sh`) est ensuite lanc√© dans cette session et permet l‚Äôex√©cution des commandes.

#### √âtape 2:  Connexion local
Depuis  la console VirtualBox (tty) connectez vous avec le m√™me compte `alice`, puis, dans cette session locale :
```sh
ps | grep alice
```

R√©sultats attendu:
```sh
alpine:~$ ps | grep alice
 2712 root      0:00 /bin/login -- alice
 2713 alice     0:00 -sh
 2716 alice     0:00 ps
 2717 alice     0:00 grep alice
alpine:~$
```

> [!NOTE] Explications
> La sortie de `ps` montre que la connexion locale est prise en charge par le programme **`login`**, ex√©cut√© avec l‚Äôidentit√© **root**, visible sous la forme `/bin/login -- alice`. Ce processus assure l‚Äôauthentification de l‚Äôutilisateur et d√©clenche l‚Äôouverture de la session.  
> Une fois l‚Äôidentit√© valid√©e, la **session utilisateur** est ouverte avec l‚Äôidentit√© de **alice**, puis le programme associ√© au compte est lanc√©, ici un shell (`-sh`) afin de pourvoir int√©ragir avec le syst√®me.

On a constat√© que, selon le mode d‚Äôacc√®s, **des programmes diff√©rents assurent l‚Äôauthentification**, tandis que le d√©roulement de l'ouverture de session reste identique. Dans le cas d‚Äôune connexion distante, l‚Äôauthentification est prise en charge par **`sshd`** ; dans le cas d‚Äôune connexion locale, elle est assur√©e par **`login`**.

Une fois l‚Äôidentit√© valid√©e, le syst√®me proc√®de √† **l‚Äôouverture d‚Äôune session utilisateur**. Cette session est associ√©e √† l‚Äôidentit√© de l‚Äôutilisateur (UID, groupes, environnement) et constitue le **contexte d‚Äôex√©cution** sur le syst√®me. Le programme associ√© au compte est alors lanc√© dans cette session, le plus souvent un **shell interactif**, qui permet l‚Äôex√©cution des commandes.

Il faut retenir que **ce n‚Äôest pas le shell qui est responsable de l‚Äôauthentification ni de la cr√©ation de la session** : il s‚Äôagit simplement d‚Äôun programme ex√©cut√© _dans_ une session d√©j√† ouverte.

## 2.4.2 L‚Äôenvironnement de session et les profils

Lors de l‚Äôouverture d‚Äôune session sur un syst√®me POSIX, le shell ex√©cute `/etc/profile`, puis `~/.profile` s‚Äôil existe.  
Ces fichiers d√©finissent l‚Äôenvironnement de la session.

Le fichier `/etc/profile` d√©finit l‚Äôenvironnement commun √† tous les utilisateurs.  
Le fichier `~/.profile` permet √† un utilisateur de compl√©ter ou de modifier cet environnement pour sa propre session.

> [!NOTE] `~` et `$HOME`  
> `~` et `$HOME` d√©signent le r√©pertoire personnel de l‚Äôutilisateur.  
> Par exemple, pour l‚Äôutilisateur `alice`, `~` correspond √† `/home/alice`.

Parmi les param√®tres d√©finis lors de l‚Äôouverture d‚Äôune session, certains influencent directement les droits appliqu√©s aux fichiers et r√©pertoires cr√©√©s par l‚Äôutilisateur.  
L‚Äôun de ces param√®tres est `umask`.

## 2.4.3 Le param√®tre `umask`

Lorsqu‚Äôun utilisateur cr√©e un fichier ou un r√©pertoire, le syst√®me ne choisit pas les permissions au hasard.  
Il applique des permissions par d√©faut, puis retire automatiquement certains droits √† l‚Äôaide d‚Äôun param√®tre appel√© `umask`.

Le `umask` est un **masque de permissions** associ√© √† un processus.  
Il est appliqu√© **uniquement au moment de la cr√©ation** d‚Äôun fichier ou d‚Äôun r√©pertoire.  
Il n‚Äôa **aucun effet r√©troactif** sur des objets d√©j√† existants.

Le r√¥le du `umask` est de **retirer des permissions**, jamais d‚Äôen ajouter.
### Permissions par d√©faut

Par convention POSIX, les permissions de d√©part sont :
- `777` pour un r√©pertoire ;
- `666` pour un fichier.

Le `umask` est alors **soustrait** √† ces valeurs pour produire les permissions finales.

Avec un `umask` de `022` :
- un r√©pertoire est cr√©√© avec les droits `755` ;
- un fichier est cr√©√© avec les droits `644`.
### Observation du `umask`

Affichez la valeur actuelle du `umask` :
```
umask
```
Cr√©ez ensuite un fichier et observez ses permissions :
```
touch test1
ls -l test1
```

Les droits observ√©s correspondent aux permissions par d√©faut **moins** le `umask`.

### Modification du `umask`

Changez le `umask` pour la session en cours :
```
umask 077
```

Cr√©ez un nouveau fichier :
```
touch test2
ls -l test2
```

Le second fichier est cr√©√© avec des permissions plus restrictives.  
Le premier fichier n‚Äôest pas modifi√©.

Cela montre que le `umask` agit **uniquement lors de la cr√©ation**.
### Port√©e et limites du `umask`

Le `umask` est un **param√®tre de processus**, h√©rit√© par les processus fils.  
Il s‚Äôapplique √† tous les fichiers et r√©pertoires cr√©√©s depuis la session.

Le `umask` n‚Äôest **pas un m√©canisme de s√©curit√© fort**.  
Il ne corrige pas des permissions incorrectes sur un r√©pertoire existant.  
Il ne prot√®ge pas contre une modification volontaire des droits apr√®s cr√©ation.

Son r√¥le est de d√©finir une **politique de droits par d√©faut coh√©rente**.

### Mise en place d‚Äôune politique globale

Pour appliquer un `umask` identique √† toutes les sessions utilisateur, il doit √™tre d√©fini dans le profil syst√®me.

√âditez le fichier `/etc/profile` en tant que root :
```
nano /etc/profile
```

Ajoutez en fin de fichier :
```
umask 027
```

Ce r√©glage s‚Äôappliquera √† toute nouvelle session ouverte sur le syst√®me.

> [!NOTE] Questions
> Quels seront les droits par d√©faut :
>  - d‚Äôun fichier cr√©√© par un utilisateur ?
>  - d‚Äôun r√©pertoire cr√©√© par un utilisateur ?


### Bonus .profile
Pour vous facilitez l'administration, on peut utiliser le .profile de root pour afficher un bandeau d'information .

1) Connectez-vous √† root
2) Cr√©ez le fichier .profile √† la $HOME de root (c-√†-d /root)
3) Collez ceci:
```
clear

# Affichage uniquement pour un shell interactif sur un terminal
case "$-" in *i*) ;; *) return ;; esac
[ -t 1 ] || return

_user="${USER:-root}"
_host="$(hostname 2>/dev/null)"
_date="$(date 2>/dev/null)"

_connexion="locale"
[ -n "$SSH_CONNECTION" ] && _connexion="SSH"

_uptime="$(uptime 2>/dev/null | sed 's/.*up \([^,]*\),.*/\1/' | sed 's/^ *//')"
[ -n "$_uptime" ] || _uptime="(inconnu)"

_disk="$(df -h / 2>/dev/null | awk 'NR==2{print $4 " libres / " $2 " (" $5 " utilis√©)"}')"
[ -n "$_disk" ] || _disk="(inconnu)"

_sessions="$(who 2>/dev/null | wc -l | tr -d ' ')"
[ -n "$_sessions" ] || _sessions="?"

# Interfaces r√©seau IPv4 (align√©es)
_net_lines="$(ip -4 addr show scope global 2>/dev/null | awk '
/^[0-9]+:/ {iface=$2; sub(":", "", iface)}
/inet / {printf "%-10s : %s\n", iface, $2}
')"
[ -n "$_net_lines" ] || _net_lines="(aucune)"

# Route par d√©faut (simplifi√©e)
_route="$(ip route show default 2>/dev/null | head -n1 | awk '{print "via " $3 " dev " $5}')"
[ -n "$_route" ] || _route="(aucune)"

print_line() {
  # Tronque √† 48 caract√®res max pour √©viter tout d√©bordement
  printf "‚îÇ %-48.48s ‚îÇ\n" "$1"
}

print_sep() {
  printf "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n"
}

print_top() {
  printf "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
}

print_bottom() {
  printf "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
}

print_top
print_line "SESSION ADMINISTRATEUR"
print_sep
print_line "Utilisateur : ${_user}@${_host}"
print_line "Connexion   : ${_connexion}"
print_sep
printf "%s\n" "$_net_lines" | while IFS= read -r l; do
  print_line "$l"
done
print_line "Route def.  : ${_route}"
print_sep
print_line "Date        : ${_date}"
print_line "Uptime      : ${_uptime}"
print_line "Disque /    : ${_disk}"
print_line "Sessions    : ${_sessions}"
print_bottom

```

> [!NOTE] Conclusion  
> Au cours de ce TP, vous avez identifi√© les diff√©rentes √©tapes qui m√®nent √† l‚Äôacc√®s au syst√®me : l‚Äôauthentification, l‚Äôouverture de session et la mise en place de l‚Äôenvironnement utilisateur. Vous avez observ√© le r√¥le r√©el des programmes impliqu√©s (`login`, `sshd`, le shell), ainsi que l‚Äôinfluence des profils et du `umask` sur le contexte de travail.  
> √Ä partir de ces m√©canismes fondamentaux, **√† vous d‚Äôimaginer ce qu‚Äôil est possible de mettre en place pour contr√¥ler, restreindre ou adapter l‚Äôacc√®s au syst√®me selon les usages et les besoins**
