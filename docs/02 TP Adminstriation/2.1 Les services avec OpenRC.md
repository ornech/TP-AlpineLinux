# 2.1 Les services avec OpenRC

> [!cite] ‚òï A la machine √† caf√© de CorpTech
> > _¬´ √Ä l‚Äô√©poque, quand on demandait au prestataire si le serveur tournait, la discussion devenait soudainement assez floue...  ¬ª_

Donc avant d‚Äôaller plus loin, on va poser les bases de ce qu‚Äôest r√©ellement un programme, un d√©mon, et comment un service est cens√© fonctionner sur un syst√®me Alpine Linux.
## 2.1.1. Un programme
Sur un syst√®me Unix, un **programme** c'est simplement un fichier **ex√©cutable**.  Lorsqu‚Äôil est lanc√© par un utilisateur, il devient un **processus** : le noyau lui attribue un **identifiant**, un **espace m√©moire**, du **temps processeur** et les ressources n√©cessaires √† son ex√©cution.
### Processus IDentifiant  (PID)
La commande `ps` affiche la liste des **processus en cours d‚Äôex√©cution** sur le syst√®me
```
ps
```

```
 2491 alice     0:00 sshd-session: alice@pts/0
 2492 alice     0:00 -sh
 2538 alice     0:00 ps
```

Observations :

- chaque ligne correspond √† un programme en cours d‚Äôex√©cution ;
- la premi√®re colonne est un **num√©ro** : le **PID**.
- la seconde colonne correspond √† **l‚Äôutilisateur propri√©taire du processus** ici **alice**;
- la troisi√®me colonne indique le **temps CPU consomm√©** par le processus ;
- la derni√®re colonne indique **le programme lanc√©**, avec ses arguments √©ventuels.

> [!NOTE] A retenir
> Un processus est un programme en cours d‚Äôex√©cution, identifi√© par un PID (ProcessID)  ex√©cut√© par un utilisateur.

> [!info] Information
BusyBox est un **binaire unique** qui regroupe de nombreuses commandes Unix (ps, ls, cp, mount, kill, etc.).  Chaque commande n‚Äôest donc pas un programme ind√©pendant mais un m√™me et unique binaire **BusyBox**. La sortie exact de ps sur d'autre distribution peut varier, mais les colonnes restent conceptuellement les m√™mes.

**Un fichier ex√©cutable et un processus sont deux choses tr√®s diff√©rentes.**  
Par exemple le fichier ex√©cutable `/bin/ps` existe en permanence sur le disque, m√™me lorsque la commande `ps` n‚Äôest pas utilis√©e.  Lorsqu‚Äôil est ex√©cut√©, le noyau cr√©e un **processus distinct** √† partir de ce fichier : il lui attribue un PID, de la m√©moire, un √©tat et du temps processeur.  Une fois l‚Äôex√©cution termin√©e, le processus dispara√Æt, mais le fichier ex√©cutable reste inchang√©.

**Un processus n‚Äôest donc pas un fichier.**  
En revanche, sur les syst√®mes Unix, le noyau **expose l‚Äô√©tat des processus** √† travers un pseudo-syst√®me de fichiers : `/proc`.

Faites le test:
```
ls /proc
```

On y trouve notamment :

- des **dossiers num√©rot√©s** : un par processus (PID) ;    
- A l'int√©rieur de ces dossiers, des **fichiers** d√©crivant l'√©tat d'un processus (m√©moire, CPU, etc.).

Concr√®tement si vous voyez un dossier `/proc/2435`, c'est que le processus **2435 est actif**.  Ce dossier **existe tant que ce processus tourne** . Ce dossier dispara√Æt d√®s que le processus 2435 sera arr√™t√©.

Faisons un premier test. La commande `sleep`  demande au noyau d‚Äôattendre pendant un temps donn√© en secondes.
```
sleep 300
```

Le terminal est bloqu√©, rien ne s‚Äôaffiche, rien ne peut √™tre saisi. Pourtant, **quelque chose est toujours en cours d‚Äôex√©cution**. 

Utilisez le raccourci CTRL+Z pour **stopper** le processus. Il est suspendu par le signal SIGTSTP et **n‚Äôest plus ex√©cut√© du tout** (temps CPU fig√©).

```
Ctrl + Z
[1]+  Stopped  sleep 300
```
Un processus stopp√© **existe toujours**, mais le noyau ne lui attribue plus de temps processeur. 

Affichez les processus en cours d'ex√©cution:
```
ps
```
Notez le PID du processus 'sleep 300'. Pour mon cas c'est le 3170.

Afficher le contenu du dossier /proc:
```
ls /proc
```
Vous devriez voir le dossier correspondant √† votre PID.

Le processus est maintenant stopp√©. Pour reprendre son ex√©cution, on demande au noyau de lui d√©livrer `SIGCONT` (reprise) via `kill`.

Pour cela tapez la commande :
```
kill -CONT <N¬∞ de PID>
```
L‚Äôoption `-CONT` demande au noyau de reprendre l‚Äôex√©cution d‚Äôun processus **stopp√©**.

Retenez que la commande `kill` demande au noyau d‚Äôenvoyer un signal √† un processus cible. 
### C‚Äôest quoi un signal ?

> [!NOTE]  Rappel
> - Le noyau (kernel) est la partie centrale du syst√®me d‚Äôexploitation.  
> - Il s‚Äôex√©cute en permanence, en mode privil√©gi√©, et contr√¥le l‚Äôacc√®s au processeur, √† la m√©moire, aux p√©riph√©riques et aux processus.  
> - Un processus utilisateur ne peut pas agir directement sur les ressources : toute action passe par le noyau.

Un signal est un m√©canisme du noyau qui permet d'imposer un √©v√©nement √† un processus.

Certains signaux proviennent du **terminal** (`Ctrl+C` -> SIGINT , `Ctrl+Z` -> SIGTSTP), d‚Äôautres sont envoy√©s explicitement via la commande `kill`. Le noyau transmet le signal au processus quelle que soit son origine. 

| Signal      | N¬∞  | √Ä quoi il sert                                  | Commande associ√©e                 |
| ----------- | --- | ----------------------------------------------- | --------------------------------- |
| **SIGTERM** | 15  | Demander √† un programme de s‚Äôarr√™ter proprement | `kill <PID>` / `kill -TERM <PID>` |
| **SIGKILL** | 9   | Forcer l‚Äôarr√™t imm√©diat (dernier recours)       | `kill -KILL <PID>`                |
| **SIGINT**  | 2   | Interruption depuis le clavier (`Ctrl+C`)       | `kill -INT <PID>`                 |
| **SIGSTOP** | 19  | Suspension forc√©e d‚Äôun processus                | `kill -STOP <PID>`                |
| **SIGCONT** | 18  | Reprise d‚Äôun processus suspendu                 | `kill -CONT <PID>`                |
Exemples:
```
kill -KILL <PID>    # arr√™t brutal
kill -STOP <PID>    # suspension forc√©e
kill -CONT <PID>    # reprise
kill -INT  <PID>    # interruption (√©quivalent Ctrl+C)
```


> [!NOTE] Petite nuance
> **SIGSTOP** et **SIGTSTP** ont le m√™me effet observable : ils suspendent un processus jusqu‚Äô√† la r√©ception de **SIGCONT**.  
La diff√©rence porte sur **l‚Äôorigine du signal** et sur **le contr√¥le laiss√© au processus**.
> - **SIGSTOP** est envoy√© par le noyau via la commande (`kill -STOP <PID>`). Le processus **ne peut ni l‚Äôintercepter, ni l‚Äôignorer**.
> - **SIGTSTP** (_terminal stop_) est envoy√© depuis un terminal lorsqu'un utilisateur tape `Ctrl+Z`. Le processus a la possibilit√© de **l‚Äôintercepter ou de l‚Äôignorer**.

### Synth√®se 
> - Un programme lanc√© devient un **processus**.  
> - Un processus a un **PID** et une **existence visible dans `/proc`**.  
> - `Ctrl+C` interrompt
> - `Ctrl+Z` suspend.  
> - `kill` demande au noyau d‚Äôenvoyer un signal √† un processus cible.
> - `kill -9` (`-9` est l‚Äô√©quivalent num√©rique de `-KILL`) impose un arr√™t brutal **sans nettoyage** (attention aux  verrous, fichiers temporaires ou sockets laiss√©s en l‚Äô√©tat).

## 2.1.2. Un d√©mon (daemon)

Certains programmes doivent fonctionner **en continu** pour fournir une fonctionnalit√© aux utilisateurs comme un service web (serveur apache2 ou nginx).

> [!NOTE]
> Un d√©mon est un programme con√ßu pour fonctionner **sans interaction utilisateur**, d√©tach√© de tout terminal, g√©n√©ralement lanc√© au d√©marrage par le syst√®me d‚Äôinitialisation.

> [!example] Exemples
> - `sshd` ‚Üí permet l‚Äôex√©cution d'un Shell s√©curis√© √† distance
> - `crond` ‚Üí ex√©cute les t√¢ches planifi√©es
> - `nginx` ‚Üí permet l'acc√®s √† des pages web
> - `syslogd` ‚Üí enregistre les logs

Donc a priori ces programmes devrait pouvoir:

- d√©marrer tout seul d√®s que le syst√®me est pr√™t,
- fonctionner en arri√®re-plan,
- et rester actifs m√™me si aucun utilisateur ne les utilise.

Le probl√®me fondamental est que si un d√©mon d√©marre un peu quand il en a envie, il y a de forte chance pour que l'environnement syst√®me ne soit pas encore pr√™t . Par exemple si :

- `sshd` se lance avant que le r√©seau ne soit initialis√©, son lancement √©chouera.    
- `nginx` √©chouera si le dossier de logs n‚Äôest pas mont√©.
- `crond` agira de fa√ßon incoh√©rente si l‚Äôheure n‚Äôest pas encore r√©gl√©e.

> [!NOTE]
> Un d√©mon seul ne sait pas quand d√©marrer, ni g√©rer ses d√©pendances, ni attendre que l‚Äôenvironnement soit pr√™t et encore moins se relancer en cas d'√©chec.

## 2.1.3. Le d√©marrage d‚Äôun syst√®me Linux
Revenons un instant sur la s√©quence de d√©marrage d'un OS (m√™me si cela n'a aucun secret pour vous ...) Quand la machine s‚Äôallume  :

1. L'UEFI initialise les p√©riph√©rique puis rend la main 
2. Le noyau Linux se charge .
3. Les syst√®mes de fichiers sont mont√©s.
4. Les pilotes s‚Äôinitialisent.
5. Les interfaces r√©seau apparaissent.
6. Les d√©mons peuvent enfin d√©marrer.

> [!NOTE]
> Encore une fois un d√©mon ne sait pas dans quel ordre se placer dans cet ordre logique, d'autant plus qu'un d√©mon n'a pas de vue sur l'√©tat du syst√®me.
> **Il lui faut donc un chef d‚Äôorchestre.**

![[2.2 TP Les services avec OpenRC.png]]
## 2.1.4. Pourquoi orchestrer les d√©mons ?
Comme on vient de le voir, sans orchestration, on obtiendrait des erreurs impr√©visibles les d√©mons s'activeraient dans un ordre al√©atoire, des d√©pendances entre d√©mons ne seraient pas respect√©es et au final on obtiendrait un syst√®me instable, incoh√©rent et surtout pas fiable. 

Pour que tout fonctionne correctement, on a besoin d'un m√©canisme qui :

- organise les **d√©pendances** entre d√©mons,
- sait **dans quel ordre** d√©marrer les d√©mons,
- sait **quand** un d√©mon peut d√©marrer,
- sait **arr√™ter proprement** un d√©mon,
- sait **v√©rifier son √©tat**,
- sait **activer/d√©sactiver le d√©marrage automatique** d'un d√©mon .

C‚Äôest le travail du **syst√®me d‚Äôinitialisation** (init system) et donc d'OpenRC 

## 2.1.5. OpenRC

OpenRC est le **chef d‚Äôorchestre** de notre distribution Alpine Linux. Il fournit :

### 2.1.5.a Un cadre pour d√©crire chaque service
 Chaque service poss√®de un script dans  /etc/init.d/ o√π il est indiqu√© :
 
  - comment d√©marrer,
  - comment s'arr√™ter,
  - de quoi d√©pend le service.

### 2.1.5.b Un syst√®me de d√©pendances
Exemple :
```sh
depend() {
    need net
}
```
OpenRC en d√©duit automatiquement l‚Äôordre de d√©marrage.

### 2.1.5.c Un m√©canisme d‚Äôauto-d√©marrage
Sur Alpine Linux, un **runlevel** est **un r√©pertoire** qui regroupe les services devant √™tre lanc√©s √† un moment donn√© du d√©marrage ou de l‚Äôarr√™t du syst√®me.

Concr√®tement :

- chaque runlevel correspond √† un **√©tat logique du syst√®me** ;
- un service est ¬´ dans un runlevel ¬ª s‚Äôil existe **un lien symbolique** vers son script dans ce r√©pertoire.

``` sh
ls /etc/runlevels/boot/
bootmisc    hostname    hwclock     loadkmap    modules     networking  seedrng     swap        sysctl      syslog
```

```
ls /etc/runlevels/default/
acpid   crond   ntpd    sshd    syslog
```

Exemples  :

- `/etc/runlevels/boot/` : services indispensables au d√©marrage (montage, udev, etc.)
- `/etc/runlevels/default/` : services lanc√©s par d√©faut 
- `/etc/runlevels/shutdown/` : services arr√™t√©s lors de l‚Äôextinction

Par exemple quand tu fais :

`rc-update add sshd`

OpenRC cr√©e un lien symbolique vers `/etc/init.d/sshd` dans `/etc/runlevels/default/`.

```
alpine:~$ ls -la /etc/runlevels/default/
total 8
drwxr-xr-x    2 root     root          4096 Dec 21 17:46 .
drwxr-xr-x    7 root     root          4096 Nov 21 23:26 ..
lrwxrwxrwx    1 root     root            17 Nov 21 23:26 acpid -> /etc/init.d/acpid
lrwxrwxrwx    1 root     root            17 Nov 21 23:26 crond -> /etc/init.d/crond
lrwxrwxrwx    1 root     root            16 Nov 21 23:26 ntpd -> /etc/init.d/ntpd
lrwxrwxrwx    1 root     root            16 Nov 21 23:26 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root            18 Dec 21 17:46 syslog -> /etc/init.d/syslog
```

> [!NOTE] Point cl√© √† retenir :
> Un runlevel est une liste de services que le syst√®me doit activer ou d√©sactiver √† un moment donn√© de son ex√©cution.

### 2.1.5.d Une interface uniforme pour g√©rer les services
OpenRC fournit une commande unique (`rc-service`) permettant d‚Äôex√©cuter les actions (start, stop,  status ... ) d√©finies dans les scripts `/etc/init.d` :
```
rc-service <service> start
rc-service <service> stop
rc-service <service> status
```

Jetez un oeil au script d'initialisation du d√©mon sshd :
```
cat /etc/init.d/sshd
```

### 2.1.5.e Un arr√™t structur√© du syst√®me
OpenRC orchestre l‚Äôarr√™t des services en s‚Äôappuyant sur les scripts `/etc/init.d` et sur le runlevel `shutdown`, ce qui conduit √† :

- respecter l‚Äôordre impos√© par les d√©pendances,
- ex√©cuter les routines d‚Äôarr√™t d√©finies par chaque service,
- ne pas intervenir au-del√† de ce que pr√©voit le script.

## 2.1.6. Synth√®se

### Du programme ‚Üí au d√©mon ‚Üí orchestration ‚Üí OpenRC
1. **Un programme** est ex√©cut√© ponctuellement.
2. **Un d√©mon** fonctionne en continu en arri√®re-plan.
3. Un d√©mon √©choue si l‚Äôenvironnement n‚Äôest pas pr√™t.
4. Il faut donc **orchestrer l‚Äôordre de d√©marrage**.
5. Cette orchestration est assur√©e par le **syst√®me d‚Äôinitialisation**.
6. Sur Alpine Linux, ce r√¥le est rempli par **OpenRC**.
7. OpenRC rend le d√©marrage **pr√©visible et reproductible**.
8. OpenRC **ne garantit ni la disponibilit√©, ni la relance automatique** d‚Äôun service d√©faillant.

> [!summary] En r√©sum√©  
> Les d√©mons accomplissent les t√¢ches.  
> OpenRC organise leur ex√©cution.


> [!NOTE] Pour info
>Par d√©faut sur **Alpine Linux**, le _Kernel Watchdog_ n‚Äôest ni activ√© ni configur√©. Ce m√©canisme du noyau Linux permet de red√©marrer automatiquement le syst√®me en cas de blocage irr√©cup√©rable (watchdog = ¬´ chien de garde ¬ª). Alpine ne l‚Äôactive pas par d√©faut, car son utilisation n√©cessite l‚Äôinstallation d‚Äôun d√©mon et de d√©pendances suppl√©mentaires, ce qui augmenterait la surface d‚Äôattaque. 
>Retenez simplement qu‚Äôil est possible d‚Äôutiliser un m√©canisme pour surveiller **des services, processus ou ressources sp√©cifiques**, mais celui-ci **n‚Äôest pas activ√© par d√©faut** et doit √™tre install√©/configur√© manuellement.

## 2.1.7. R√©f√©rences

> [!summary]
> 
> - Alpine Linux ‚Äì OpenRC  
>     [https://wiki.alpinelinux.org/wiki/OpenRC](https://wiki.alpinelinux.org/wiki/OpenRC)
>     
> - Gentoo ‚Äì OpenRC Handbook  
>     [https://wiki.gentoo.org/wiki/OpenRC](https://wiki.gentoo.org/wiki/OpenRC)
>         

## 2.1.8. Exercices

### üìù **Exercice 1 ‚Äì D√©couverte**

> [!warning] √Ä rendre
> 
> 1. Listez **tous** les services disponibles.
>     
> 2. Listez les services activ√©s au d√©marrage.
>     
> 3. Donnez le chemin exact du script `networking`.
>     
> 
> **Format attendu : commandes + r√©ponses.**

### üìù **Exercice 2 ‚Äì Manipulation**

> [!warning] √Ä rendre
> 
> 1. D√©marrez `crond`.
> 2. V√©rifiez son √©tat.
> 3. Activez-le au d√©marrage.
> 4. Red√©marrez la machine.
> 5. V√©rifiez qu‚Äôil est bien lanc√© apr√®s reboot.
> 
> **Justifiez votre r√©ponse √† l‚Äôaide de `ps` ou `rc-status`. **

### üìù **Exercice 3 ‚Äì Analyse**

> [!warning] √Ä rendre
> 
> Expliquez la diff√©rence entre :
> 
> ```
> rc-service sshd start
> ```
> 
> et
> 
> ```
> rc-update add sshd
> ```
> 
> (Attendu : start = ex√©cution imm√©diate, add = d√©marrage automatique au prochain boot.)

### üìù **Exercice 4 ‚Äì Recherche documentaire**

> [!warning] √Ä rendre
> 
> √Ä partir des sources officielles Alpine :
> 
> ‚úîÔ∏è Expliquez le r√¥le de :
> 
> - `/etc/init.d`
>     
> - `/etc/runlevels/default`
>     
> - `/etc/conf.d`
>     
> 
> ‚úîÔ∏è Citez les URLs et extraits pertinents.
