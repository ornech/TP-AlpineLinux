Les droits POSIX 

Trois catÃ©gories dâ€™accÃ¨s :
- **user** : le propriÃ©taire du fichier
- **group** : le groupe associÃ©    
- **other** : tous les autres utilisateurs

Trois permissions 
- **r** : lire
- **w** : Ã©crire
- **x** : exÃ©cuter (ou _entrer dans un dossier_)

> Plus tard nous verrons quâ€™il existe Ã©galement quelques **bits spÃ©ciaux** (SUID, SGID, sticky), mais restons dâ€™abord sur lâ€™essentiel.

## Comment Ã§a marche ?
Les permissions POSIX sont appliquÃ©es **aux trois catÃ©gories** (user, group, other).
Prenons un exemple concret:
CrÃ©ons un fichier :
```
touch test.txt
ls -l test.txt
-rw-------    1 root     etudiants            0 Dec  1 16:07 test.txt
```
Pour lire le bloc `-rw-------`, il suffit de le dÃ©couper en segments :
- le **type** du fichier (premier caractÃ¨re)
- les **droits du propriÃ©taire** (3 caractÃ¨res suivants)
- les **droits du groupe** (3 suivants)
- les **droits des autres** (3 derniers)

Voici la reprÃ©sentation visuelle :
```
[-][rw-][---][---]
 |   |    |    |
 |   |    |    â””â”€â”€â”€â”€ other  (autres utilisateurs)
 |   |    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ group  (groupe propriÃ©taire)
 |   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ user   (propriÃ©taire)
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ type   (fichier, dossier, lienâ€¦)

```
Ton contenu est **excellent sur le fond**, mais il peut Ãªtre **nettement amÃ©liorÃ©** sur trois points :

1. **ClartÃ© pÃ©dagogique** (surtout l'accÃ¨s Ã  la notion de bits pour des dÃ©butants)
    
2. **Formulation** (il reste des maladresses ou rÃ©pÃ©titions)
    
3. **CohÃ©rence logique** (l'ordre des explications peut Ãªtre optimisÃ©)
    

ðŸ‘‰ **Ci-dessous, je te propose une version rÃ©visÃ©e**, fidÃ¨le Ã  ce que tu veux transmettre, mais plus propre, fluide et rigoureuse.  
Je te mets **uniquement des amÃ©liorations**, pas une rÃ©Ã©criture totale.

### Comment lâ€™interprÃ©ter ?
Chaque permission (**r**, **w**, **x**) correspond Ã  un **bit**.  
Un bit peut Ãªtre :
- **1** â†’ droit activÃ©
- **0** â†’ droit dÃ©sactivÃ©

La somme des bits activÃ©s donne la **valeur octale** utilisÃ©e ensuite par `chmod`.
Voici notre exemple :
```
-rw-------
```

| CaractÃ¨re | Signification                                          |
| --------- | ------------------------------------------------------ |
| `-`       | type : fichier rÃ©gulier (un dossier serait `d`)        |
| `rw-`     | droits du propriÃ©taire (**user**) : lecture + Ã©criture |
| `---`     | droits du groupe (**group**) : aucun droit             |
| `---`     | droits des autres (**other**) : aucun droit            |
### Comprendre les bits et leur poids

Chaque position (r, w, x) est associÃ©e Ã  une **puissance de 2** :

| Rang    | 2      | 1      | 0      |
| ------- | ------ | ------ | ------ |
| Valeur  | 2Â² = 4 | 2Â¹ = 2 | 2â° = 1 |
| Binaire | 100    | 010    | 001    |
| Droit   | r      | w      | x      |

**Rappel :**  
La valeur dâ€™un droit correspond Ã  **2 puissance son rang**.  
Exemple : rang 1 â†’ 2Â¹ = 2 â†’ droit dâ€™Ã©criture.

### Exemple : Lecture + Ã©criture uniquement (`rw-`)

On active uniquement :
- le bit lecture (**r**, rang 2)
- le bit Ã©criture (**w**, rang 1)

```md
| Rang    | 2      | 1      | 0      |
|---------|--------|--------|--------|
| Valeur  | 4      | 2      | 1      |
| Droit   | r      | w      | x      |
| Binaire | 1      | 1      | 0      |
```

Somme des bits activÃ©s :
```
4 + 2 + 0 = 6
```
Donc :
```
rw- â†’ 110 en binaire â†’ 6 en octal
```
### Exemple : Lecture + exÃ©cution (`r-x`)

```md
| Rang    | 2      | 1      | 0      |
|---------|--------|--------|--------|
| Valeur  | 4      | 2      | 1      |
| Droit   | r      | w      | x      |
| Binaire | 1      | 0      | 1      |
```

Somme :
```
4 + 0 + 1 = 5
```
Donc :
```
r-x â†’ 101 en binaire â†’ 5 en octal
```

## Tableau rÃ©capitulatif complet

|Valeur octale|rwx|
|---|---|
|0|---|
|1|--x|
|2|-w-|
|3|-wx|
|4|r--|
|5|r-x|
|6|rw-|
|7|rwx|
# 5. DiffÃ©rence entre fichiers et dossiers
Les droits POSIX ne se comportent **pas du tout de la mÃªme maniÃ¨re** selon quâ€™il sâ€™agit dâ€™un **fichier** ou dâ€™un **dossier**.

Voyons cela par la pratique. Avec l'utilisateur root, crÃ©er un dossier `testdroit` Ã  la racine ainsi qu'un fichier `fichier.txt`:
```sh
mkdir /testdroit
touch /testdroit/fichier.txt
```
On affiche les droits du dossier 
```sh
ls -ld /testdroit/
drwxr-xr-x    2 root     root          4096 Dec  1 16:59 /testdroit/
```
`r-xr-x` indique un dossier (`d`) dont le propriÃ©taire peut tout faire (`rwx`), tandis que le groupe et les autres utilisateurs peuvent seulement lire et entrer dans le dossier (`r-x`).

Maintenant modifions ces droits 
```sh
chmod 700 /testdroit
ls -ld /testdroit/
drwx------    2 root     root          4096 Dec  1 16:59 /testdroit/

```
`drwx------` indique un dossier dont seul le propriÃ©taire peut lire son contenu, y entrer et le modifier, tandis que le groupe et les autres n'ont absolument aucun accÃ¨s.

Essayons d'y accÃ©der depuis le compte de Alice :
```sh
su - alice
cd /testdroit
sh: cd: can't cd to testdroit/: Permission denied
```
Comme le `cd` Ã©choue, câ€™est quâ€™il manque le droit dâ€™accÃ¨s au dossier. Ajoutons donc lâ€™autorisation nÃ©cessaire.
```
su - root
chmod 0+x /testdroit/
```

> [!NOTE]
> `chmod o+x` modifie **uniquement la classe â€œotherâ€** (les autres utilisateurs, câ€™est-Ã -dire tous ceux qui ne sont ni le propriÃ©taire ni dans le groupe du fichier).
> - `o` = **others**
> - `+` = **ajouter**
> - `x` = **le droit dâ€™exÃ©cution**

AprÃ¨s lâ€™ajout du droit `0+x`, les permissions deviennent :
```
ls -ld /testdroit/
drwx-----x    2 root     root          4096 Dec  1 16:59 /testdroit/
```

```sh
su - alice
cd /testdroit
ls /testdroit
```

> [!NOTE] A retenir
> Sur un dossier, **x** autorise lâ€™accÃ¨s (`cd`), tandis que **r** autorise lâ€™affichage de son contenu (`ls`). Sans **x**, on ne peut pas entrer ; sans **r**, on peut entrer mais pas voir ce quâ€™il contient.

# 6. CrÃ©ation dâ€™un groupe pour un dossier partagÃ©

CrÃ©er un groupe :

```sh
addgroup projet
```

Ajouter les utilisateurs :

```sh
addgroup alice projet
addgroup bob projet
```

# 7. CrÃ©er le dossier partagÃ©

CrÃ©er :

```sh
mkdir /projet
```

Affecter le groupe :

```sh
chown :projet /projet
```

> [!NOTE]
> La commande **`chown`** permet de modifier les deux propriÃ©tÃ©s dâ€™un fichier ou dâ€™un dossier :
> - `chown user fichier` â†’ change **le propriÃ©taire** (user)
> - `chown :group fichier` â†’ change **le groupe propriÃ©taire**
> - `chown user:group fichier` â†’ change **les deux Ã  la fois**

Mettre les droits adÃ©quats :
```sh
chmod 770 /projet
```

- 7 : propriÃ©taire â†’ total
- 7 : groupe â†’ total
- 0 : autres â†’ aucun accÃ¨s
    

# 8. Introduire une erreur volontaire (trÃ¨s formateur)

```sh
chmod 700 /projet
```

- Alice peut accÃ©der
- Bob **ne peut plus** â†’ erreur


**Corriger :**

```sh
chmod 770 /projet
```

# 9. VÃ©rifier lâ€™isolation des dossiers personnels

Depuis Bob :

```sh
su - bob
cd /home/alice
```

RÃ©sultat attendu :

```
Permission denied
```

Explication :

- le home de chaque utilisateur est gÃ©nÃ©ralement en `700`
- Bob nâ€™a ni `x` ni `r` et ne peut donc pas entrer
    

Compris.  
Voici une **version entiÃ¨rement didactique**, avec **dÃ©monstrations pas Ã  pas**, tests concrets, rÃ©sultats attendus, et explications immÃ©diatement exploitables en TP.

Je te redonne **uniquement la section 10**, rÃ©Ã©crite correctement, prÃªte Ã  intÃ©grer en Markdown.

# 10. MÃ©canismes avancÃ©s
Ces notions sont trÃ¨s puissantes en administration systÃ¨me.  
# 10.1 Sticky Bit â€“ EmpÃªcher la suppression des fichiers des autres

Par exemple _(le comportement de /tmp : n'importe qui peut y Ã©crire, mais personne ne peut supprimer les fichiers des autres)_ . En somme un dossier partagÃ© oÃ¹ l'on **peut  Ã©crire**, mais **pas la supprimer** des fichiers des autres.

```sh
mkdir /partage_sticky
chmod 777 /partage_sticky
```

Ajouter Alice et Bob si nÃ©cessaire :
```sh
addgroup projet
addgroup alice projet
addgroup bob projet
```
1. Alice crÃ©e un fichier :    
    ```sh
    su - alice
    touch /partage_sticky/alice.txt
    exit
    ```
2. Bob tente de supprimer le fichier dâ€™Alice :
    ```sh
    su - bob
    rm /partage_sticky/alice.txt
    ```
**RÃ©sultat attendu :**  Le fichier est supprimÃ©.  
**Pourquoi ?**  Le dossier est en `777` : tout le monde peut tout supprimer.

## Activons le sticky bit
```sh
chmod +t /partage_sticky
```
VÃ©rification :
```sh
ls -ld /partage_sticky
```
â†’ le `t` apparaÃ®t Ã  la fin :
```
drwxrwxrwt  ...
```
## Test avec sticky bit

Alice recrÃ©e son fichier :

```sh
su - alice
touch /partage_sticky/alice.txt
exit
```

Bob tente de le supprimer :

```sh
su - bob
rm /partage_sticky/alice.txt
```

**RÃ©sultat attendu :**

```
rm: cannot remove 'alice.txt': Operation not permitted
```

âž¡ï¸ **DÃ©monstration parfaite :**  
Un dossier partagÃ© peut devenir _sÃ©curisÃ©_ sans casser les permissions dâ€™Ã©criture.


# 10.2 Setgid sur un dossier â€“ Tous les fichiers hÃ©ritent du bon groupe

## Objectif

Dans un dossier partagÃ©, les fichiers doivent appartenir **automatiquement** au groupe du projet.  
Sinon, Alice crÃ©era un fichier appartenant Ã  son groupe primaire (souvent `alice`) et **Bob ne pourra pas lâ€™utiliser**.

## Mise en place

CrÃ©er un dossier partagÃ© neutre :

```sh
mkdir /projet_sg
addgroup gprojet
addgroup alice gprojet
addgroup bob gprojet
chown :gprojet /projet_sg
chmod 770 /projet_sg
```

## Test sans setgid

Alice crÃ©e un fichier :

```sh
su - alice
touch /projet_sg/a.txt
ls -l /projet_sg/a.txt
exit
```

RÃ©sultat typique :

```
-rw-r--r-- 1 alice alice   0 Jan 26 10:05 a.txt
```

âž¡ï¸ Le groupe est **alice**, pas `gprojet`.

**ConsÃ©quence :**  
Bob peut entrer dans le dossier, mais **ne pourra pas modifier le fichier**.

## Activer le setgid

```sh
chmod g+s /projet_sg
```

VÃ©rification :

```sh
ls -ld /projet_sg
```

â†’ On voit un **s** dans la colonne des droits du groupe :

```
drwxrws---  ...
```

## Test avec setgid

Alice crÃ©e un autre fichier :

```sh
su - alice
touch /projet_sg/b.txt
ls -l /projet_sg/b.txt
exit
```

RÃ©sultat attendu :

```
-rw-r--r-- 1 alice gprojet 0 Jan 26 10:08 b.txt
```

âž¡ï¸ Cette fois, **le fichier appartient automatiquement au groupe du projet**.

Bob peut travailler dessus sans problÃ¨me.

# Quâ€™est-ce que _umask_ ?

**umask** signifie **User Mask** ou **Permission Mask**.  
Câ€™est un **masque de permissions** appliquÃ© automatiquement par un processus lorsquâ€™un fichier est crÃ©e .

> [!NOTE]
> **Le umask (User File-Creation Mode Mask)** est une valeur octale propre Ã  chaque processus. Elle nâ€™intervient **que lorsquâ€™un fichier ou un rÃ©pertoire est crÃ©Ã©** par ce processus : le umask est alors **soustrait** au mode POSIX par dÃ©faut afin de dÃ©terminer les **permissions finales** de lâ€™objet nouvellement crÃ©Ã©.  


Observez comment umask influence les permissions _au moment de la crÃ©ation_ d'un fichier
DÃ©monstration
Affichez le umask actuel :
```
umask
```
RÃ©sultat attendu : 
- Pour un dossier : 777 â€“ 022 = 755  
- Pour un fichier : 666 â€“ 022 = 644

CrÃ©ez un fichier
```
touch test1
ls -l test1
```

Changez le umask en 077
```
umask 077
```
CrÃ©ez un second fichier :
```
touch test2
ls -l test2
```
Comparez les permissions.
- test1 â†’ `rw-r--r--`
- test2 â†’ `rw-------`



Pour rappel : 

> [!NOTE] umask = **attribut dâ€™un processus**
>  - agit **uniquement lors de la crÃ©ation** de fichiers/rÃ©pertoires
>  - fonctionne en **retirant** des permissions
>  - nâ€™a **aucun effet aprÃ¨s coup**
>  - ne protÃ¨ge pas si le dossier parent est trop permissif
>  - ne doit pas Ãªtre considÃ©rÃ© comme un mÃ©canisme fort de sÃ©curitÃ©



> [!NOTE]
> **â€œThe umask is simply a process property. Nothing more, nothing less.â€**  
> _(LKML â€“ Linus Torvalds)_
