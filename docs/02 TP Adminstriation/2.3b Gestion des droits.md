Les droits POSIX : le strict nécessaire

Trois catégories d’accès :

- **owner** : propriétaire
- **group** : groupe associé
- **others** : les autres utilisateurs
    

Trois permissions :

- **r** : lire
- **w** : écrire
- **x** : exécuter / entrer dans un dossier
    

> Pour _entrer dans un dossier_, le droit essentiel est **x**.

# 5. Différence entre fichiers et dossiers (test court)

Créer un dossier de test :

```sh
mkdir /testdroit
touch /testdroit/f1
chmod 500 /testdroit
```

Depuis Alice :

```sh
su - alice
cd /testdroit        # OK
ls /testdroit        # Permission denied
```

> `x` permet d'entrer,  
> `r` permet de lister le contenu.

# 6. Création d’un groupe pour un dossier partagé

Créer un groupe :

```sh
addgroup projet
```

Ajouter les utilisateurs :

```sh
addgroup alice projet
addgroup bob projet
```

# 7. Créer le dossier partagé

Créer :

```sh
mkdir /projet
```

Affecter le groupe :

```sh
chown :projet /projet
```

Mettre les droits adéquats :

```sh
chmod 770 /projet
```

- 7 : propriétaire → total
- 7 : groupe → total
- 0 : autres → aucun accès
    

# 8. Introduire une erreur volontaire (très formateur)

```sh
chmod 700 /projet
```

- Alice peut accéder
- Bob **ne peut plus** → erreur


**Corriger :**

```sh
chmod 770 /projet
```

# 9. Vérifier l’isolation des dossiers personnels

Depuis Bob :

```sh
su - bob
cd /home/alice
```

Résultat attendu :

```
Permission denied
```

Explication :

- le home de chaque utilisateur est généralement en `700`
- Bob n’a ni `x` ni `r` et ne peut donc pas entrer
    

Compris.  
Voici une **version entièrement didactique**, avec **démonstrations pas à pas**, tests concrets, résultats attendus, et explications immédiatement exploitables en TP.

Je te redonne **uniquement la section 10**, réécrite correctement, prête à intégrer en Markdown.

# 10. Mécanismes avancés
Ces notions sont très puissantes en administration système.  
# 10.1 Sticky Bit – Empêcher la suppression des fichiers des autres

Par exemple _(le comportement de /tmp : n'importe qui peut y écrire, mais personne ne peut supprimer les fichiers des autres)_ . En somme un dossier partagé où l'on **peut  écrire**, mais **pas la supprimer** des fichiers des autres.

```sh
mkdir /partage_sticky
chmod 777 /partage_sticky
```

Ajouter Alice et Bob si nécessaire :
```sh
addgroup projet
addgroup alice projet
addgroup bob projet
```
1. Alice crée un fichier :    
    ```sh
    su - alice
    touch /partage_sticky/alice.txt
    exit
    ```
2. Bob tente de supprimer le fichier d’Alice :
    ```sh
    su - bob
    rm /partage_sticky/alice.txt
    ```
**Résultat attendu :**  Le fichier est supprimé.  
**Pourquoi ?**  Le dossier est en `777` : tout le monde peut tout supprimer.

## Activons le sticky bit
```sh
chmod +t /partage_sticky
```
Vérification :
```sh
ls -ld /partage_sticky
```
→ le `t` apparaît à la fin :
```
drwxrwxrwt  ...
```
## Test avec sticky bit

Alice recrée son fichier :

```sh
su - alice
touch /partage_sticky/alice.txt
exit
```

Bob tente de le supprimer :

```sh
su - bob
rm /partage_sticky/alice.txt
```

**Résultat attendu :**

```
rm: cannot remove 'alice.txt': Operation not permitted
```

➡️ **Démonstration parfaite :**  
Un dossier partagé peut devenir _sécurisé_ sans casser les permissions d’écriture.


# 10.2 Setgid sur un dossier – Tous les fichiers héritent du bon groupe

## Objectif

Dans un dossier partagé, les fichiers doivent appartenir **automatiquement** au groupe du projet.  
Sinon, Alice créera un fichier appartenant à son groupe primaire (souvent `alice`) et **Bob ne pourra pas l’utiliser**.

## Mise en place

Créer un dossier partagé neutre :

```sh
mkdir /projet_sg
addgroup gprojet
addgroup alice gprojet
addgroup bob gprojet
chown :gprojet /projet_sg
chmod 770 /projet_sg
```

## Test sans setgid

Alice crée un fichier :

```sh
su - alice
touch /projet_sg/a.txt
ls -l /projet_sg/a.txt
exit
```

Résultat typique :

```
-rw-r--r-- 1 alice alice   0 Jan 26 10:05 a.txt
```

➡️ Le groupe est **alice**, pas `gprojet`.

**Conséquence :**  
Bob peut entrer dans le dossier, mais **ne pourra pas modifier le fichier**.

## Activer le setgid

```sh
chmod g+s /projet_sg
```

Vérification :

```sh
ls -ld /projet_sg
```

→ On voit un **s** dans la colonne des droits du groupe :

```
drwxrws---  ...
```

## Test avec setgid

Alice crée un autre fichier :

```sh
su - alice
touch /projet_sg/b.txt
ls -l /projet_sg/b.txt
exit
```

Résultat attendu :

```
-rw-r--r-- 1 alice gprojet 0 Jan 26 10:08 b.txt
```

➡️ Cette fois, **le fichier appartient automatiquement au groupe du projet**.

Bob peut travailler dessus sans problème.

# Qu’est-ce que _umask_ ?

**umask** signifie **User Mask** ou **Permission Mask**.  
C’est un **masque de permissions** appliqué automatiquement par lun processus lorsqu’un fichier est crée 

> [!NOTE]
> **Le umask (User File-Creation Mode Mask)** est une valeur octale propre à chaque processus. Elle n’intervient **que lorsqu’un fichier ou un répertoire est créé** par ce processus : le umask est alors **soustrait** au mode POSIX par défaut (666 pour les fichiers, 777 pour les répertoires) afin de déterminer les **permissions finales** de l’objet nouvellement créé.  

> [!NOTE] umask = **attribut d’un processus**
>  - agit **uniquement lors de la création** de fichiers/répertoires
>  - fonctionne en **retirant** des permissions
>  - n’a **aucun effet après coup**
>  - ne protège pas si le dossier parent est trop permissif
>  - ne doit pas être considéré comme un mécanisme fort de sécurité

**“The umask is simply a process property. Nothing more, nothing less.”**  
_(LKML – Linus Torvalds)_

Exemple simple
`umask 022`

### Fichier :

Mode POSIX : 666  
Umask : -022  
Résultat : **644**

→ Le fichier est lisible par tous.

### Répertoire :

Mode POSIX : 777  
Umask : -022  
Résultat : **755**

→ Le répertoire est traversable par tous.

C’est **ce qu’on observe par défaut** sur Alpine, Debian, Ubuntu…


