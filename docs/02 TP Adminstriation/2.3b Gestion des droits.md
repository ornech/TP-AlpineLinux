# 2.3b Gestion des droits Linux 
## Présentation du contexte professionnel

Vous venez d’être recruté chez **TechCorp**, une PME de 50 salariés spécialisée dans les services numériques.  
La direction vous a confié une mission un peu particulière pour votre arrivée :  
reprendre en main un serveur de fichiers Linux qui vient d’être “installé” par un prestataire manifestement incompétent.

Les symptômes sont nombreux :  
- les commerciaux qui ne peuvent pas accéder à leurs documents,  
- les développeurs qui se plaignent que “tout le monde peut lire le code source”,  
- les fichiers de la direction visibles par des personnes qui n’auraient jamais dû y avoir accès,  
- les scripts d’administration sont impossibles à lancer,  
- plus tous ce qui n'a pas encore été découvert...

Votre rôle, en tant que stagiaire fraîchement embauché au service **INFRA**, est de :
-  analyser l’existant sans tout casser ;    
- identifier les erreurs de droits et de structure ;
- proposer et appliquer des corrections cohérentes avec l’organisation de l’entreprise ;
- vérifier, pour chaque service (DEV, INFRA, COM, DIR), que les accès correspondent bien à ce qui est attendu.

> [!warning] Don't panic
> Ce TP sera votre guide.

Mais avant de commencer, récupérez ce script et exécutez le en root sur votre VM. 

> [!NOTE] 
> Ne regardez pas trop ce que fait ce script ... vous vous en doutez un peu je pense ... c'est une vraie boucherie ... un carnage !

Une fois le script exécuté, nous allons pouvoir commencer.
## Les droits POSIX

Les systèmes Unix (dont Linux) utilisent un modèle de permissions appelé **POSIX**.  Il repose sur **trois catégories** d’utilisateurs (user / group / other) et **trois permissions** (r / w / x).

C’est la base absolument indispensable pour comprendre pourquoi un fichier est accessible… ou non.

### Les trois catégories d’accès

Chaque fichier (ou dossier) appartient à :
- **user** → son propriétaire
- **group** → un groupe d’utilisateurs
- **other** → tous les autres utilisateurs du système

Un fichier a donc **trois ensembles distincts de permissions**.

### Les trois permissions

- **r** (read) → lire le fichier, ou lister le contenu d’un dossier
- **w** (write) → modifier un fichier, ou créer/supprimer dans un dossier
- **x** (execute) → exécuter un programme, ou _entrer dans un dossier_

> Plus tard : nous verrons les **bits spéciaux** (SUID, SGID, Sticky Bit) qui ajoutent des comportements supplémentaires.

### Comment lire les droits ?
La commande `ls` permet de lister le contenu d'un dossier mais également d'afficher les propriétés associées à un fichier ou un dossier .

Prenons un exemple simple :
```
touch test.txt                  # création d'un fichier vide
ls -l test.txt
```
Résultat typique (si vous avez a): 
```
-rw-------    1 root     etudiants            0 Dec  1 16:07 test.txt
```
exemple :
`-rw-r-----  1 alice dev 428 Dec  1 16:07 rapport.txt`

![[Droits - teste presta.png]]

La première colonne [-rw-------] représente l'ensemble des droits** du fichier.

Elle de découpe en quatre blocs :
```
[-][rw-][---][---]
 |   |    |    |
 |   |    |    └─── other  (autres utilisateurs)
 |   |    └──────── group  (groupe propriétaire)
 |   └───────────── user   (propriétaire)
 └───────────────── type   (fichier, dossier, lien…)
```

Interprétation (de la gauche vers la droite):
- **type** : `-` → c'est un fichier (pas un dossier)
- **user** : `rw-` → le propriétaire peut lire (read) et écrire (write)
- **group** : `---` → le groupe n’a aucun droit
- **other** : `---` → les autres n’ont aucun droit

Vous vous en êtes sans doute aperçu, les système UNIX utilisent **deux notations complémentaires** :
- une **notation symbolique**, comme `rw-rw-r--`, pensée pour l’humain. On peut voir d’un coup d’œil qui peut lire, écrire ou exécuter ;
- une **notation octale**, comme `664`, utilisée par les commandes (`chmod`, `umask`) car elle correspond directement au fonctionnement interne du système.

Cette notation octale s’explique par la manière dont est enregistré les permissions (r, w, x) pour le propriétaire, groupe et les autres. Chaque droits (r,w,x) est associé à **un bit**, que l'on active ou pas. Si on active  :
-  le premier bit `x`(exécution)  vaut **1** (premier rang  2⁰ = 1)
- le second bit `w` (écriture) vaut **2** (deuxième rang  2¹ = 2)
- le troisième bit `r`(lecture) vaut **4** (troisième rang  2² = 4)

Comment vous le savez dès lors  que l'on active un bit, la valeur de son rang s'ajoute aux autres rangs pour former une valeur totale. Par exemple :
Mais si on active
-  `r` et `w` cela donne 4 + 2 = **6**
- `r` et `x` cela donne 4 + 1 = **5**
- `w` et `x` cela donne 2 + 1 = **3**
- `r`, `w` et `x` cela donne 4 + 2 + 1 = **7**

Un trio de permissions peut donc produire **8 valeurs possibles**, de 0 (`---`) à 7 (`rwx`).  
Comme ces huit valeurs se représentent naturellement par **un seul chiffre en base 8**, Unix a choisi l’octal pour coder les droits : la valeur octal décrit un trio r/w/x . On a donc trois bits successifs qui décrivent les droits du propriétaire, puis trois bits pour le groupe et et 3 bits pour les autres.

À ces trois catégories classiques - propriétaire, groupe et autres - s’ajoutent trois autres **bits spéciaux** (SUID, SGID et Sticky), destinés à régler certains comportements particuliers que l'on verra plus tard.

Voici le tableau complet:
![[2.3b Gestion des droits.png]]

### Premiers constats possibles

Grâce à `ls -l`, vous pouvez dès maintenant :
- identifier **qui possède un fichier**,
- vérifier **à quel groupe il appartient**,
- repérer **qui a le droit de lire, écrire, exécuter un fichier ou d'accéder à un dossier**,

> [!NOTE] Commandes utiles
> ls -l                      # lire les droits, propriétaires et groupes
> ls -ld dossier    # lire les droits du dossier lui-même
> stat fichier       # afficher des informations détaillées

**Travail demandé**
1) A partir des commande que vous avez vu, remplissez le tableau suivant :

| Dossier          | Propriétaire (user) | Groupe propriétaire | droits (user) | droits (group) | droits (others) | risques |
| ---------------- | ------------------- | ------------------- | ------------- | -------------- | --------------- | ------- |
|                  |                     |                     |               |                |                 |         |
| /srv/commerciaux |                     |                     |               |                |                 |         |
| /srv/commun      |                     |                     |               |                |                 |         |
| /srv/dev         |                     |                     |               |                |                 |         |
| /srv/direction   |                     |                     |               |                |                 |         |
| /srv/infra       |                     |                     |               |                |                 |         |

2) Lister les comptes présents sur le serveur. 
3) Sont-ils cohérent avec la liste suivante? 
	Voici la liste des employés 
		**Direction (DIR)**
		- `mdupont` (Marie Dupont) – Directrice
		- `acarlier` (Antoine Carlier) – Directeur adjoint
		**Commercial (COM)**
		- `lroux` (Laura Roux)
		- `sbernard` (Sébastien Bernard) 
		- `jmartin` (Julie Martin)
		**Développement (DEV)**
		- `nlambert` (Nicolas Lambert) 
		- `tgarcia` (Thomas Garcia)
		- `dvasseur` (Daniel Vasseur)
		- `mthomas` (Maëlle Thomas)
		- `lhenry` (Loïc Henry)
		**Infrastructure (INFRA)**
		- `rduval` (Romain Duval)
		- `jmorel` (Julie Morel)

4) Les comptes sont-ils associés à un groupe de service (métier) ?  
5) Le script de backup est-il exécutable ?
6) Le catalogue commercial est-il modifiable par tout le monde ?
7) Le budget est-il lisible uniquement par la direction ?
8) Le readme développeur peut-il  être modifié par un commercial ?

> [!warning] 
> **On ne peut pas réparer les accès aux dossiers métier tant que la structure des groupes n’existe pas.**  
> 
> Et encore moins tant que les bons utilisateurs ne sont pas associés aux bons groupes.

# 2) Association utilisateur -> groupe
## Création des groupes métiers

Les services de TechCorp sont :
- **DEV** : développement
- **INFRA** : administration système et réseau
- **COM** : service commercial
- **DIR** : direction

> [!NOTE] Travail demandé
> Créer les quatre groupes correspondants.  
> Aucune option particulière n’est nécessaire : un groupe POSIX simple suffit.

## Attacher un utilisateur à son groupe

Une fois les groupes créés, rattachez :
- chaque développeur au groupe **DEV**,
- chaque administrateur au groupe **INFRA**,
- chaque commercial au groupe **COM**,
- chaque membre de la direction au groupe **DIR**.


> [!NOTE] Travail demandé
> Associez chaque utilisateur à son groupe primaire **en modifiant son compte**, pas en ajoutant un groupe secondaire.

# 3) Correction des droits POSIX
Avant de corriger les accès aux répertoires métiers, il faut savoir comment modifier les droits POSIX.  
La commande `chmod` permet d’ajouter ou de retirer des permissions sur les trois ensembles : **user**, **group**, **other**.

Le principe est simple :
- `chmod +…` ajoute un droit ;
- `chmod -…` retire un droit ;
- `u`, `g` et `o` désignent respectivement le propriétaire, le groupe et les autres utilisateurs.

Par exemple :
- `chmod g+r` ajoute(+) la lecture(r) au groupe(g),
- `chmod o-x` retire(-) le droit d'exécution (si fichier) ou  d'accès (si dossier) aux “other”(o),
- `chmod u+w` ajoute(+) l’écriture(w) au propriétaire(u).
- `chmod 640` soit 6 → `rw-` pour le propriétaire, 4 → `-r-`  et 0 →`---` pour les autres

## Réparation de `/srv/commerciaux/`

**Constat :**
```
drwxrwxr-x    2 root     root   4096 Dec  3 14:12 commerciaux
```

A priori il y a deux problèmes :
1. le **groupe propriétaire** est `root` au lieu de `com` ;
2. les permissions **laissent entrer et lire tous les utilisateurs** (`r-x` pour _others_).

Cela signifie qu’un développeur, un admin ou même un invité peut parcourir ce dossier — ce qui est inacceptable pour notre directeur commercial .

> [!NOTE]  
> La commande **`chown`** permet de modifier la propriétaire et le groupe propriétaire :
> 
> - `chown user fichier` → change le propriétaire
>     
> - `chown :groupe fichier` → change le groupe propriétaire
>     
> - `chown user:groupe fichier` → change les deux en même temps
>     
> 
> Exemple :  
> `chown :invite /srv/stagiaire/`  
> Remplace le groupe propriétaire actuel par le groupe `invite`pour le dossier `/srv/stagiaire`. Notez que cette commande n'est pas récursive (ne se propage pas aux répertoires avals). C'est possible, mais lisez la doc de chmod pour ça. 

> [!NOTE]  Travail demandé
> 1. Donner au groupe **COM** le contrôle du dossier `/srv/commerciaux/`
> 2. Restreindre totalement l’accès aux autres services
 

> Objectif :
> - COM → lire, écrire, entrer dans le dossier
> - autres → aucun accès, même pas lister son contenu

➜ Validez en testant l’accès avec un utilisateur COM et un utilisateur non-COM.

## Réparation de `/srv/dev/`
Appliquer exactement la même démarche que pour `/srv/commerciaux/`, cette fois en attribuant le groupe propriétaire **DEV**, puis en ajustant les droits pour que seuls les membres de ce groupe puissent entrer et travailler dans `/srv/dev/`.

## Réparation de `/srv/direction/`
Réaliser la correction en attribuant le groupe propriétaire **DIR**.  
Le répertoire de la direction doit être **strictement réservé** au groupe DIR, sans aucune permission pour les autres services.

## Réparation de `/srv/infra/`
Corriger le répertoire en attribuant le groupe propriétaire **INFRA**.  
Les administrateurs doivent être les seuls habilités à entrer dans `/srv/infra/` et à modifier son contenu.

## Sticky Bit
Le **sticky bit**, c’est un petit mécanisme utilisé **uniquement sur les dossiers**. Il sert à **empêcher les utilisateurs de supprimer les fichiers des autres**. C'est tout.
Certains dossiers commun à plusieurs utilisateurs** (droits en écriture pour tous), on veut permettre à chacun :
- de **déposer** ses fichiers,
- de **modifier** ses propres fichiers,
- mais **PAS de supprimer ou renommer ceux des autres**.
###  Correction du `/srv/commun/` 
Les différents services disposent de documents dans `/srv/commun/` mais visiblement  
tout le monde peut supprimer n'importe quels fichiers.

> [!warning] Travail demandé
> Activer le Sticky Bit sur ce dossier et corriger les droits pour que seul le propriétaire puisse supprimer ou modifier ses propres fichiers, les autres doivent avoir un accès uniquement en lecture.

## Setgid

### Cas d’usage (sauvegardes INFRA)
Dans le service INFRA, plusieurs administrateurs doivent pouvoir **déposer**, **consulter**, **vérifier**, **déplacer** ou **supprimer** des sauvegardes dans un dossier commun.  
Sans setgid, chaque archive hériterait du groupe personnel de l’admin qui l’a créée, ce qui empêcherait les autres de la gérer.

En activant le setgid sur `/srv/backup/`, **toutes les sauvegardes héritent automatiquement du groupe `infra`**, ce qui permet à toute l’équipe de gérer le dossier de manière cohérente.

**Travail demandé**  
Activer le setgid sur `/srv/dev/` pour assurer un groupe unique DEV sur tous les fichiers.

**Validation**  
Créer deux fichiers depuis deux comptes DEV → vérifier le groupe.


# 4) Mise en situation finale

## Cahier des charges complet

Reprendre l’ensemble du serveur et produire **une politique d’accès complète**, conforme aux besoins métier.

**Les étudiants doivent documenter :**
- ce qu’ils ont constaté,
- ce qu’ils ont modifié,
- pourquoi,
- et comment ils ont validé.

# Quiz & erreurs professionnelles

## Questions finales

Sous forme de diagnostics courts :  
“Voici les droits, voici l’erreur → que proposez-vous ?”
